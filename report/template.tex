\input{preamble.tex}

\title{CI/CD with Jenkins and Beaker}
\author{Thomas Løkkeborg} % TODO add studnr

\begin{document}

\maketitle

\abstract{CI/CD is high-level term that is hard to grasp without practical examples. In this report I will put forward my own experiences from trying to set up a Jenkins CI/CD pipline running in OpenStack using Beaker and Vagrant.}

\thispagestyle{empty}

\clearpage
\pagenumbering{roman}
\setcounter{page}{1}
\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Introduction}

The original goal of this project was to experiment with CI/CD using Jenkins and Beaker. As a vessel for achieving this goal I decided to try and create an infrastructure with a Puppet Master, a Jenkins server and an application server, where changes to the infrastructure were run through a CI/CD pipeline on the Jenkins server. The whole infrastructure should be completely defined in code, such that all that is needed to bring up a copy is some environment-dependant yaml files and a \mintinline{bash}{openstack create} command.

The components of the infrastructure that I want to test are the control-repo and the application running on the application server.

A lot of the work done during the project is in research, and I will try and share what I have learned during the project in this report. 

%This is a short template you can use for your project report. Feel free to
%make your own modifications to the structure. 
%
%Join together to form project groups of max three people in each group (you can
%also be just one if you prefer to work alone).
%
%For the topic you choose write a report of ca 5-15 pages plus appendices (and prepare a 5-10
%minute presentation).
%
%Try to write as scientifically correct as you can. Write objectively, do not
%write like you are telling a story: "first we did this, then we did that, ...".
%Use correct citations, here are some examples of how to cite correctly:
%\begin{itemize}
%\item Dag Langmyrs \LaTeX book~\cite{Langmyr:03}
%\item Journal articles like~\cite{Klein:09}
%\item Conference proceedings articles like~\cite{Begnum:07} 
%\item Wikipedia pages like~\cite{wikipedia:kerberos:10}
%\end{itemize}
%
%NOTE: it is EXTREMELY important that you write in your own words, and not
%just translate something you find. 
%
%If you want to write ``the perfect introduction'' I strongly suggest you
%read Claerbout's ``Scrutiny of the introduction''~\cite{Claerbout:95}.
%
%Describe what you will do in the introduction chapter (What are the goals of
%you project?).

\section{Background technology and terms}

\subsection{CI/CD}

As the whole project is focused around CI/CD I feel it's appropriate to present the definition of the term I've been using during the project. The term refers to the combined practise of "Continous Integration" and "Continous Delivery". Our course book refers to Martin Fowler for definitions of these terms, so I will as well.

\subsubsection{Continous Integration}

%CITATION https://martinfowler.com/articles/continuousIntegration.html

Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly.

\subsubsection{Continous Delivery}

%CITATION https://martinfowler.com/bliki/ContinuousDelivery.html

Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time.

\subsection{Beaker}

Beaker is a test harness focused on acceptance testing machines. The project is maintained by Puppetlabs themselves, and is widely used. Beaker abstracts away the underlying machines it is testing on by using the concept of SUTs, "Systems Under Test", so it can test for any kind of machine that is supported though plugins. The project consists of many parts, and the relevant ones for this project are "beaker-openstack" and "beaker-vagrant".

% NOT NEEDED?
%\subsubsection{beaker-rspec}

%Beaker-rspec incorporates the popular testing framework Rspec into the Beaker ecosystem. Rspec tests are 

\subsubsection{beaker-openstack}

Beaker-openstack is meant to allow Beaker to use OpenStack as a provider of SUTs. This plugin is experimental, and the library code reflects that. I have not found any examples of people actually using this plugin.

\subsubsection{beaker-vagrant}

Beaker-vagrant utilizes Vagrant to create and provision nodes. When using this plugin Beaker will create Vagrant configuration files for you, so it seems like there is no room for customization at the Vagrant layer.

\subsection{Vagrant}

Vagrant is an Open-source automation tool for creating and provisioning virtual machines. It was created to make it straight-forward to create disposable and reproducable virtual machines defined in code. It is from my understanding primarily used to create development envirornments, but it can be used for anything involving virtual machines. Vagrant is not tied to any particular virtualization technology, and uses the concept of "providers" to as a high-level abstraction for underlying hypovisors. As Vagrant is widely used you can find providers for pretty much anything. Worth mentioning is the VirtualBox and OpenStack providers, which are the ones I used during this project. The VirtualBox provider is the most popular choice, due to how simple it is to set up. There are a couple OpenStack providers, but I chose to use "vagran-openstack-provider", as it bases it's machines on images from OpenStack, whereas the other one uses OpenStack compliant boxes.

\subsection{Jenkins Configuration as Code}

Jenkins Configuration as Code, or JCasC, is a Jenkins plugin that seeks to replace the Jenkins web UI with yaml configuration files. Using this plugin it is possible to completely configure a Jenkins server through code. The project has been accepted as a standard component of the Jenkins project, and will be incorporated into Jenkins itself eventually. JCasC is very new, so documentation is sparse.

%Describe the technology involved, you do not have to explain something you have
%learned in the course, but explain any additional technology that you use in
%the prpoject.

\section{Survey of similar projects}

Following are the projects I looked at when trying to set up control-repo testing. Testing of my application is more of a "solved issue", so I did not look to any specific project for that.

\subsection{PSICK}

"Puppet Systems Infrastructure Construction Kit", or "PSICK", is a feature-rich tool for generating Puppet control-repos. Control-repos generated by this tool come with many features included, and one of those are testing. The project uses Beaker for testing, and allows for testing on Docker containers or through Vagrant.

I did not choose to use this project as my control-repo because it seems rather complex, and because it seems to rely on either Vagrant with VirtualBox or Docker to run it's Beaker tests.

\subsection{Onceover}

Onceover is a tool for generating and running tests for control-repos. It seems very promising, as it automatically generates tests by looking through your existing codebase. It used to support acceptance testing through Beaker, but the maintainers have abandoned Beaker to look for a more general solution to acceptance testing. I did try and set this up for my project, but could not find a way to make it run on OpenStack.

\subsection{Acceptance testing at OpenStack}

OpenStack is using a combination of Vagrant and Beaker to run their Puppet module tests on OpenStack instances. Because the support for OpenStack nodes is so poor they have decided to create the SUTs via Vagrant using OpenStack as the provider, install Beaker as part of the provisioning process and run Beaker directly on the host (Vagrant controlled) machine by setting Beaker's hyporvisor to "none".

%\subsection{puppetlabs-ntp} for beaker-rspec stuff?

%There are always someone who has done what you are going to do, or
%something related. Breifly describe at least one or two similar projects,
%to motivate what your contribution will be (Google/DuckDuckGo the best you can
%and find similar projects).

\section{Description of your work}

% som jeg ser det: beskriv hva jeg brukte tiden på

Following is a description of what I spent my time working on during the project.

\subsection{Research}

During the project research was done so I had a general idea of how people where solving the issues I was working on. As a result of this I'm left with a better perspective on automated testing, the Jenkins ecosystem, on Beaker and on Vagrant.

\subsection{The imt3005-project-cicd repository}

This repository serves as the control-repo for the infratructure I built during the project, and also includes OpenStack Heat code to bring up a stack running the control-repo. During the project I manually tested features directly on the OpenStack instances of the stack, and tried to incorporate changes into this repository once they were stable enough.

TBA: WHAT IS ACTUALLY SET UP

\subsection{The imt3005-vagrant-vm repository}

This repository contains the Vagrant environment I used to develop for this project. It includes all the tooling needed to work with the course, and is written to be general enough that other people might find it useful. It is not the focus of this report, but I feel it is worth mentioning, as the bulk of my Vagrant experimentation ended up being setting up this environment.

%Describe what you have done (or are doing), relate it the the previous work
%you described in the previous chapter if appropriate.

\section{Results and discussion}

\subsection{OpenStack Heat stack}

A core part of this project was having the infrastructure completely defined in code, so creating the stack was key. I based my infrastructure on IaC-Heat-cr, so creating the initial setup was went quite quickly. What I've needed to change from that stack was to reduce it down to three machines, make it use my own control-repo instead of contro-repo-cr and to inject some ssh keys through the bootscripts ran at stack creation.
\\
I decided to have the infrastructure definition in the same repository as the control-repo for simplicity. This proved to be beneficial as the infrastructure definition and control-repo always were in-sync. A side-effect is that r10k deploys the infrastructure definition together with the roles and profiles, which seems a little dirty. 

\subsection{Beaker}

Beaker proved to be more difficult to work with than expected. The intial goal was to have my whole control-repo tested through Beaker, but this proved to be a difficult task inside of Skyhigh. 

\subsubsection{Issues with the documentation}

While learning with Beaker I discovered several issues in the documentation. This seems strange, as the project appears to be well maintained. The biggest bug I found was in what might be the most important piece of documentatino of all: the "getting started" tutorial. Following the tutorial step by step rewards you with a big error message following the final command, which is not very inviting. The bug was not easy to fix either. It turns out the tutorial uses functionality from Beaker version 3 which has been completely revised for Beaker 4. Installing Puppet on SUTs used to be a part of the core Beaker project, but has since been moved out into a separate plugin and revised. This meant that before I could even run a Beaker test I had to learn one of it's plugins.
\\
I intend to create an issue on the Beaker issue tracker as soon as I have the time. This will be my first real OpenSource contribution, which is exciting.

\subsubsection{The Beaker-openstack plugin}

The most common way to run Beaker seems to be using Vagrant with VirtualBox. This was what I initially planned on doing, but it turns out Skyhigh instances do not support hardware virtualization. VirtualBox running on a system without hardware virtualization is not a pleasant experience, as virtual machines must be 32-bit, and creation and deletion will be very slow. I abandoned VirtualBox for what in principle is a much better solution anyways: using Skyhigh itself as the hyporvisor for Beaker.

In concept Beaker using Skyhigh for it's SUTs is a good idea. You could run your functional tests on the exact same images as the production systems are using. You could even provision them the exact same way as the production systems as you have access to the bootscripts for the intances in the stack. The issue is that to do this you are dependant on a plugin, and although there is a Beaker-openstack plugin, it is experimental and does not seem stable. First of all it does not immidiately seem to support OpenStack Keystone version 3, which is what Skyhigh seems to be using. Authenticating with Keystone version 2 gives 404 responses, and the top-level API call indicates it is depracted. Looking into the code for the library it does mention Keystone version 3 though, but it is using it in a very strange way. The following snippet is from the part of the library that is causing issues:

\begin{minted}[firstnumber=48,fontsize=\tiny,linenos,breaklines]{Ruby}
# Keystone version 3 requires users and projects to be scoped
if @credentials[:openstack_auth_url].include?('/v3/')
  @credentials[:openstack_user_domain]    = @options[:openstack_user_domain] || 'Default'
  @credentials[:openstack_project_domain] = @options[:openstack_project_domain] || 'Default'
end

@compute_client ||= Fog::Compute.new(@credentials)
\end{minted}

Line 48 to 52 seems like a temporary solution, as it forces you to use "Default" domain when authenticating. The domain Skyhigh is expecting is "NTNU", so this might be part of the issue. Line 54 is where the library completely fails. There is a bug from inside the function call, which is a poorly documented call to another library, so I did not spend time debugging it.

\subsubsection{Using Vagrant for creation of SUTs for Beaker}

While researching alternate approaches to having Beaker work with OpenStack this was the one that seemed the most stable. Instead of having Beaker manage it's SUTs, you instead use Vagrant and it's excellent "vagrant-openstack-plugin" to manage OpenStack instances to test on, install Beaker on the instances, and trick Beaker to run it's tests on the machine it is installed on, which is the Vagrant-managed OpenStack instance. This lets you create exact copies of the production instances, with the only difference being the Beaker installation. Beaker tests can run as normal, but you are giving away the ability to test the system from the outside, as Beaker is inside the SUT calling itself with localhost. Beaker also has the very interesting ability to create multiple SUTs and do tests between them, which you are missing out on.
\\
I did not end up implementing this in the project control-repo, but I have done enough manual testing to know that this would work. I provide the outline of how this kind of test would look like as an appendix.

% INCLUDE EXAMPLE VAGRANTFILE WITH BEAKER PROVISIONING SCRIPT AND SO ON

\subsubsection{Beaker-rspec tests for gossinbackup module}

To learn Beaker I created simple tests for my Puppet gossinbackup module. I created them to run as Vagrant with VirtualBox as a hyporvisor, so they unfortunately can not be used in the project infrastructure. INCLUDE TESTS

% INCLUDE CODE FOR THESE TESTS

\subsection{Jenkins}

Jenkins is what I spent the majority of my time working with.

\subsubsection{Jenkins Configuration as Code}

I wanted my control-repo to define my whole Jenkins setup, so I went with using the Jenkins Configuration as Code plugin for configuration. It is a very new project, so documentation is sparse. The idea behind it is to mirror the web UI setup with yaml code, but the mapping is not one-to-one, so trying to set it up without help is like shooting in the dark. After struggling with setting it up from scratch myself, I found THIS demo and based my setup around it. 
\\
The plugin does have functionality to export yaml code based on a running Jenkins instance. This does not seem very well fleshed out yet, but when this is in place creating the configuration will be a much less painful process. Once JCasC matures I believe it will be massively useful, but currently using it is pretty cumbersome.

\subsubsection{Job DSL}

I used the Job DSL plugin to define "seed jobs", which are jobs used to initialize larger jobs found elsewhere. All my testing code was written in Jenkinsfiles, which I'll discuss next. Here is an example of such a "seed job", taken from my JCasC configuration file:

\begin{minted}[fontsize=\tiny,linenos,breaklines]{yaml}
jobs:
(...)
  # sets up control-repo testing
  - script: |
      pipelineJob("control repo") {
                  definition {
                      cpsScm {
                          scm {
                              git {
                                  remote {
                                      github('tholok97/imt3005-project-cicd', 'ssh')
                                      credentials('tholok97_imt3005-project-cicd_deploy-key')
                                  }
                              }
                          }
                      }
                  }
      }
\end{minted}

Line 1 defines a list of jobs, and line 5 to 18 is a "seed job" that sets up a pipline for the control-repo. The "credentials" call on line 12 refers to a private ssh key stored using the credentials plugin. See the security discussion.

\subsection{Test pipelines}

Each pipeline has a "seed job" that simply adds the job and makes the "Jenkinsfile" found in each repository do the rest. 

\subsubsection{Control-repo}

The control-repo's pipeline currently just does linting tests and deploys to production. With more time I would have written proper Beaker tests for it using the method described earlier TODO. The following code snippet describes it's Jenkinsfile, with the parts I did not have time to write added:

\begin{minted}[fontsize=\tiny,linenos,breaklines]{groovy}
pipeline {
  agent none
  stages {
    stage('puppet parser validate') {
      agent {
        // using dockerfile defined in jenkins_agents
        dockerfile {
          dir 'jenkins_agents/syntax_agent/'
        }
      }
      steps {
        sh '/opt/puppetlabs/bin/puppet parser validate --debug --verbose .'
      }
    }
    stage('puppet-lint') {
      agent {
        // using dockerfile defined in jenkins_agents
        dockerfile {
          dir 'jenkins_agents/syntax_agent/'
        }
      }
      steps {
        sh '/usr/bin/puppet-lint --error-level all --fail-on-warnings .'
      }
    }
    
    // BEGIN NOT IMPLEMENTED. Added for demonstration
    stage() {
      agent {
        // using dockerfile defined in jenkins_agents
        dockerfile {
          dir 'jenkins_agents/vagrant_agent/'
        }
      }
      steps {
        sh './runVagrantBeakerTest.sh'
      }
    }    
    // END NOT IMPLEMENTED. Rest is present in control-repo

    stage('r10k deploy') {
      agent { label 'master' }
      steps {
        sh "ssh -o StrictHostKeyChecking=no root@manager.borg.trek 'r10k deploy environment -p --verbose'"
      }
    }
  }
}
\end{minted}



% TODO: actually write that section

\subsubsection{gossinbackup}

While learning Beaker I set up basic acceptance tests for my gossinbackup module. These run fine, but use the Vagrant and VirtualBox solution, so I can not run them with my current setup on Skyhigh. Here is what the pipeline currently looks like, with the parts I did not get to implement added. The syntax checks are the same as the ones we did in lab task 7.

\begin{minted}[fontsize=\tiny,linenos,breaklines]{groovy}
pipeline {
  agent {
    dockerfile {
      filename 'pdk_agent_dockerfile'
      dir 'jenkins_agents'
    }
  }
  stages {
    stage('Validate and lint') {
      steps {
        sh 'pdk validate metadata,puppet'
      }
    }
    stage('Unit tests') {
      steps {
        sh 'pdk test unit --debug'
      }
    }

    // BEGIN NOT IMPLEMENTED
    stage('Acceptance test') {
      steps {
        sh 'bundle install && bundle exec rspec spec/acceptance/'
        // OR
        sh './runVagrantBeakerTest.sh'
      }
    }
    // END NOT IMPLEMENTED
  }
}
\end{minted}

As indicated in the snippet, the acceptance tests could either run as standard beaker test runs, or by using the Vagrant solution I explained earlier. The first solution works, but not in Skyhigh, and the latter is not implemented.

\subsubsection{application} % TODO :1

TBA


\subsection{Vagrant-vm}

Although this was not the focus of this project, I will briefly discuss the Vagrant box I created to work with this course. Currently it includes all the tools needed, and I believe it is general enough that anyone can clone it and start using it themselves. Environment-specific configuration is done through a yaml file, and all the "data" of the environment is shared with the underlying host, so the environment is completely disposable. It gave me a chance to experiment freely, as I could simply rebuild it any time I messed up.
\\
Relevant to this project is the fact that since I've done all of my work inside this environment, it should be possible for anyone to clone it down and get the exact same setup that I've used. This one solution to the "it works on my machine" issue, as everyone will have the exact same machine. In addition it's fully possible to make this environment mirror that found in production. I have set up Vagrant to provision it's VM in Skyhigh, which allows it to use the exact same image as production does. You could take this even further by having Vagrant apply the same bootscript to it as well.



% WHAT TO TALK ABOUT
% - Stack
% - Beaker
%   - configuration
%   - 
% - JCasC
%   - configuration
%   - 
% tests:
%   - control-repo
%   - control-repo
%   - gossinbackup



%This is the longest chapter, feel free to include some figures. Include
%discussion of all problems you have encountered.

\section{Security aspects}

Security was not a primary focus of this project, so there are a few concerns that have not been fixed. I will discuss them here:

\subsection{Secrets}

Handling secrets was not a focus during this project, so I have chosen some dodgy solutions here and there. The only way of safely bringing in secrets with my setup is during provisioning of the Heat stack, by injecting them into the machines from Heat variables. The ssh key pair between the Jenkins server and the Puppet master is injected in this way, as well as the Github ssh key the Puppet master uses for r10k deploys. With access to my development machine an attacker would have access to every secret in my infrastructure, which I would consider a huge security issue for larger deployments. A solution here would be to generate the key pair between the Puppet master and Jenkins server either during stack creation or through Puppet.
\\
JCasC lets you define user passwords in plaintext in the yaml configuration file, so I chose to do that for simplicity. This is an obvious security flaw that could be fixed by the below list of solutions.
\\
The above problems are way smaller than the greatest sin I did during this project though, which was to include a private key in plaintext in the control-repo. The Jenkins server needs to authenticate with Github to clone down repositories for testing, and I did not find any straight-forward way to give Jenkins a private key for this, so I ended up just including the key as part it's JCasC configuration. The key is a "Github deploy key", however, so an attacker with access to this key would only have \textbf{read} access to \textbf{the repository the key was linked to}. There are a couple solutions to this issue:
\\
\begin{itemize}  
\item \textbf{Using JCasC secrets}: JCasC includes some basic functionality for handling secrets. One is injecting secrets into the configuration from environment variables. I could have set up environment variables during stack creation and included the deploy key this way
\item \textbf{Using hiera-eyaml}: This would allow the key to be stored in the repository in an encrypted form. A decryption key could be given to the Puppet master during stack creation.
\item \textbf{Using an external secrets technology}: There lots of technologies for keeping secrets out of version control altogether. I did not look into any of them.
\end{itemize}

\subsection{SSH keys}

Currently the Puppet master has ssh access to both of the other machines. This is for more easily debugging the infrastructure, but does mean that access to the Puppet master means access to everything. The Jenkins server also has ssh access back to the Puppet master. This is because it runs \mintinline{bash}{r10k deploy} through ssh to deploy after testing. This was done for simplicity. A more secure solution would be to set up an API endpoint on the Puppet master that runs \mintinline{bash}{r10k deploy} itself when it receives request. That way access to the Jenkins machine only means an attacker could spam deploys, which is much better than an attacker having full access to the Puppet master through ssh.

\subsection{Concerns around defining Jenkins as Code}

Keeping all test definitions under version control means that an attacker with access to my repositories could see everything I test for, and more importantly, everything I \textbf{don't} test for. This is a consequence of having everything defined as code, and makes securing the repositories even more important. This issue is somewhat mitigated by the fact that the control-repo only contains "seed jobs". The actual test definitions are in each individual repository in the form of a "Jenkinsfile".

\subsection{Infratructure defined in control-repo}

I chose to have the infrastruce definition in the control-repo, which means r10k "deploys" this code as well to the Puppet master. This means access to the Puppet master an attacker could find security holes in my setup. 

% r10k places infrastructure definion on master.... talk about taht 


%Provide a brief security analysis. Are you opening any new attack vectors? What
%are the risks? Are there sensitive data? Are clients and servers mutually
%authenticating each other? etc etc

\section{Conclusions}


* Didn't quite reach my goal
* Working with Beaker outside of Virtualbox is a hassle
* JCasC is very promising, but not very useable
* Vagrant is great
* Testing pipelines are great


TBA

%So what is the punchline, does it work or not? Do you recommend doing this
%for others?

\bibliographystyle{acmdoi}
\bibliography{template}

\clearpage
\appendix

\section{Code}

TBA

%\begin{verbatim}
%# this is just the verbatim environment, really should use
%# a proper code environement
%
%class profile::base_linux {
%
%  $linux_sw_pkg = hiera('base_linux::linux_sw_pkg')
%
%# careful when configuring ntp to avoid misuse (opening for DDOS)
%
%  class { 'ntp':
%    servers   => [ 'ntp.hig.no' ],
%    restrict  => [
%      'default kod nomodify notrap nopeer noquery',
%      '-6 default kod nomodify notrap nopeer noquery',
%    ],
%  }
%  class { 'timezone':
%    timezone => 'Europe/Oslo',
%  }
%
%  package { $linux_sw_pkg:
%    ensure => latest,
%  }
%
%}
%\end{verbatim}
%
\end{document}
