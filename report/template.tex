\input{preamble.tex}

\title{CI/CD with Jenkins and Beaker}
\author{Thomas Løkkeborg} % TODO add studnr

\begin{document}

\maketitle

\abstract{CI/CD is high-level term that is hard to grasp without practical examples. In this report I will put forward my own experiences from trying to set up a Jenkins CI/CD pipline running in OpenStack using Beaker and Vagrant.}

\thispagestyle{empty}

\clearpage
\pagenumbering{roman}
\setcounter{page}{1}
\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Introduction}

The original goal of this project was to experiment with CI/CD using Jenkins and Beaker. As a vessel for achieving this goal I decided to try and create an infrastructure with a Puppet Master, a Jenkins server and an application server, where changes to the infrastructure were run through a CI/CD pipeline on the Jenkins server. The whole infrastructure should be completely defined in code, such that all that is needed to bring up a copy is some environment-dependant yaml files and a \mintinline{bash}{openstack create} command.

The components of the infrastructure that I want to test are the control-repo and the application running on the application server.

A lot of the work done during the project is in research, and I will try and share what I have learned during the project in this report. 

%This is a short template you can use for your project report. Feel free to
%make your own modifications to the structure. 
%
%Join together to form project groups of max three people in each group (you can
%also be just one if you prefer to work alone).
%
%For the topic you choose write a report of ca 5-15 pages plus appendices (and prepare a 5-10
%minute presentation).
%
%Try to write as scientifically correct as you can. Write objectively, do not
%write like you are telling a story: "first we did this, then we did that, ...".
%Use correct citations, here are some examples of how to cite correctly:
%\begin{itemize}
%\item Dag Langmyrs \LaTeX book~\cite{Langmyr:03}
%\item Journal articles like~\cite{Klein:09}
%\item Conference proceedings articles like~\cite{Begnum:07} 
%\item Wikipedia pages like~\cite{wikipedia:kerberos:10}
%\end{itemize}
%
%NOTE: it is EXTREMELY important that you write in your own words, and not
%just translate something you find. 
%
%If you want to write ``the perfect introduction'' I strongly suggest you
%read Claerbout's ``Scrutiny of the introduction''~\cite{Claerbout:95}.
%
%Describe what you will do in the introduction chapter (What are the goals of
%you project?).

\section{Background technology and terms}

\subsection{CI/CD}

As the whole project is focused around CI/CD I feel it's appropriate to present the definition of the term I've been using during the project. The term refers to the combined practise of "Continous Integration" and "Continous Delivery". Our course book refers to Martin Fowler for definitions of these terms, so I will as well.

\subsubsection{Continous Integration}

%CITATION https://martinfowler.com/articles/continuousIntegration.html

Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly.

\subsubsection{Continous Delivery}

%CITATION https://martinfowler.com/bliki/ContinuousDelivery.html

Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time.

\subsection{Beaker}

Beaker is a test harness focused on acceptance testing machines. The project is maintained by Puppetlabs themselves, and is widely used. Beaker abstracts away the underlying machines it is testing on by using the concept of SUTs, "Systems Under Test", so it can test for any kind of machine that is supported though plugins. The project consists of many parts, and the relevant ones for this project are "beaker-openstack" and "beaker-vagrant".

% NOT NEEDED?
%\subsubsection{beaker-rspec}

%Beaker-rspec incorporates the popular testing framework Rspec into the Beaker ecosystem. Rspec tests are 

\subsubsection{beaker-openstack}

Beaker-openstack is meant to allow Beaker to use OpenStack as a provider of SUTs. This plugin is experimental, and the library code reflects that. I have not found any examples of people actually using this plugin.

\subsubsection{beaker-vagrant}

Beaker-vagrant utilizes Vagrant to create and provision nodes. When using this plugin Beaker will create Vagrant configuration files for you, so it seems like there is no room for customization at the Vagrant layer.

\subsection{Vagrant}

Vagrant is an Open-source automation tool for creating and provisioning virtual machines. It was created to make it straight-forward to create disposable and reproducable virtual machines defined in code. It is from my understanding primarily used to create development envirornments, but it can be used for anything involving virtual machines. Vagrant is not tied to any particular virtualization technology, and uses the concept of "providers" to as a high-level abstraction for underlying hypovisors. As Vagrant is widely used you can find providers for pretty much anything. Worth mentioning is the VirtualBox and OpenStack providers, which are the ones I used during this project. The VirtualBox provider is the most popular choice, due to how simple it is to set up. There are a couple OpenStack providers, but I chose to use "vagran-openstack-provider", as it bases it's machines on images from OpenStack, whereas the other one uses OpenStack compliant boxes.

\subsection{Jenkins Configuration as Code}

Jenkins Configuration as Code, or JCasC, is a Jenkins plugin that seeks to replace the Jenkins web UI with yaml configuration files. Using this plugin it is possible to completely configure a Jenkins server through code. The project has been accepted as a standard component of the Jenkins project, and will be incorporated into Jenkins itself eventually. JCasC is very new, so documentation is sparse.

%Describe the technology involved, you do not have to explain something you have
%learned in the course, but explain any additional technology that you use in
%the prpoject.

\section{Survey of similar projects}

Following are the projects I looked at when trying to set up control-repo testing. Testing of my application is more of a "solved issue", so I did not look to any specific project for that.

\subsection{PSICK}

"Puppet Systems Infrastructure Construction Kit", or "PSICK", is a feature-rich tool for generating Puppet control-repos. Control-repos generated by this tool come with many features included, and one of those are testing. The project uses Beaker for testing, and allows for testing on Docker containers or through Vagrant.

I did not choose to use this project as my control-repo because it seems rather complex, and because it seems to rely on either Vagrant with VirtualBox or Docker to run it's Beaker tests.

\subsection{Onceover}

Onceover is a tool for generating and running tests for control-repos. It seems very promising, as it automatically generates tests by looking through your existing codebase. It used to support acceptance testing through Beaker, but the maintainers have abandoned Beaker to look for a more general solution to acceptance testing. I did try and set this up for my project, but could not find a way to make it run on OpenStack.

\subsection{Acceptance testing at OpenStack}

OpenStack is using a combination of Vagrant and Beaker to run their Puppet module tests on OpenStack instances. Because the support for OpenStack nodes is so poor they have decided to create the SUTs via Vagrant using OpenStack as the provider, install Beaker as part of the provisioning process and run Beaker directly on the host (Vagrant controlled) machine by setting Beaker's hyporvisor to "none".

%\subsection{puppetlabs-ntp} for beaker-rspec stuff?

%There are always someone who has done what you are going to do, or
%something related. Breifly describe at least one or two similar projects,
%to motivate what your contribution will be (Google/DuckDuckGo the best you can
%and find similar projects).

\section{Description of your work}

% som jeg ser det: beskriv hva jeg brukte tiden på

Following is a description of what I spent my time working on during the project.

\subsection{Research}

During the project research was done so I had a general idea of how people where solving the issues I was working on. As a result of this I'm left with a better perspective on automated testing, the Jenkins ecosystem, on Beaker and on Vagrant.

\subsection{The imt3005-project-cicd repository}

This repository serves as the control-repo for the infratructure I built during the project, and also includes OpenStack Heat code to bring up a stack running the control-repo. During the project I manually tested features directly on the OpenStack instances of the stack, and tried to incorporate changes into this repository once they were stable enough.

TBA: WHAT IS ACTUALLY SET UP

\subsection{The imt3005-vagrant-vm repository}

This repository contains the Vagrant environment I used to develop for this project. It includes all the tooling needed to work with the course, and is written to be general enough that other people might find it useful. It is not the focus of this report, but I feel it is worth mentioning, as the bulk of my Vagrant experimentation ended up being setting up this environment.

%Describe what you have done (or are doing), relate it the the previous work
%you described in the previous chapter if appropriate.

\section{Results and discussion}

TBA

%This is the longest chapter, feel free to include some figures. Include
%discussion of all problems you have encountered.

\section{Security aspects}

Security was not a primary focus of this project, so there are a few concerns that have not been fixed. I will discuss them here:

\subsection{Secrets}

Handling secrets was not a focus during this project, so I have chosen some dodgy solutions here and there. The only way of safely bringing in secrets with my setup is during provisioning of the Heat stack, by injecting them into the machines from Heat variables. The ssh key pair between the Jenkins server and the Puppet master is injected in this way, as well as the Github ssh key the Puppet master uses for r10k deploys. With access to my development machine an attacker would have access to every secret in my infrastructure, which I would consider a huge security issue for larger deployments. A solution here would be to generate the key pair between the Puppet master and Jenkins server either during stack creation or through Puppet.

The above problem is way smaller than the greatest sin I did during this project though, which was to include a private key in plaintext in the control-repo. The Jenkins server needs to authenticate with Github to clone down repositories for testing, and I did not find any straight-forward way to give Jenkins a private key for this, so I ended up just including the key as part it's JCasC configuration. The key is a "Github deploy key", however, so an attacker with access to this key would only have \textbf{read} access to \textbf{the repository the key was linked to}. There are a couple solutions to this issue:

\begin{itemize}  
\item \textbf{Using JCasC secrets}: JCasC includes some basic functionality for handling secrets. One is injecting secrets into the configuration from environment variables. I could have set up environment variables during stack creation and included the deploy key this way
\item \textbf{Using hiera-eyaml}: This would allow the key to be stored in the repository in an encrypted form. A decryption key could be given to the Puppet master during stack creation.
\item \textbf{Using an external secrets technology}: There lots of technologies for keeping secrets out of version control altogether. I did not look into any of them.
\end{itemize}

\subsection{SSH keys}

Currently the Puppet master has ssh access to both of the other machines. This is for more easily debugging the infrastructure, but does mean that access to the Puppet master means access to everything. The Jenkins server also has ssh access back to the Puppet master. This is because it runs \mintinline{bash}{r10k deploy} through ssh to deploy after testing. This was done for simplicity. A more secure solution would be to set up an API endpoint on the Puppet master that runs \mintinline{bash}{r10k deploy} itself when it receives request. That way access to the Jenkins machine only means an attacker could spam deploys, which is much better than an attacker having full access to the Puppet master through ssh.

\subsection{Concerns around defining Jenkins as Code}

Keeping all test definitions under version control means that an attacker with access to my repositories could see everything I test for, and more importantly, everything I \textbf{don't} test for. This is a consequence of having everything defined as code, and makes securing the repositories even more important. This issue is somewhat mitigated by the fact that the control-repo only contains "seed jobs". The actual test definitions are in each individual repository in the form of a "Jenkinsfile".


%Provide a brief security analysis. Are you opening any new attack vectors? What
%are the risks? Are there sensitive data? Are clients and servers mutually
%authenticating each other? etc etc

\section{Conclusions}

TBA

%So what is the punchline, does it work or not? Do you recommend doing this
%for others?

\bibliographystyle{acmdoi}
\bibliography{template}

\clearpage
\appendix

\section{Code}

TBA

%\begin{verbatim}
%# this is just the verbatim environment, really should use
%# a proper code environement
%
%class profile::base_linux {
%
%  $linux_sw_pkg = hiera('base_linux::linux_sw_pkg')
%
%# careful when configuring ntp to avoid misuse (opening for DDOS)
%
%  class { 'ntp':
%    servers   => [ 'ntp.hig.no' ],
%    restrict  => [
%      'default kod nomodify notrap nopeer noquery',
%      '-6 default kod nomodify notrap nopeer noquery',
%    ],
%  }
%  class { 'timezone':
%    timezone => 'Europe/Oslo',
%  }
%
%  package { $linux_sw_pkg:
%    ensure => latest,
%  }
%
%}
%\end{verbatim}
%
\end{document}
